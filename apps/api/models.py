import uuid
from datetime import datetime

from django.db import models
from pgvector.django import VectorField, HnswIndex
from typing import Optional, List

class UploadedFile(models.Model):
    id_external = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    file_name = models.CharField(max_length=255)
    file = models.FileField(upload_to='pdf_files/')
    uploaded_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name_plural = "Uploaded Files"
    
    def __str__(self):
        return self.file_name

class FileTextExtraction(models.Model):
    id_external = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    source_file = models.ForeignKey('UploadedFile', on_delete=models.CASCADE)
    extracted_text = models.TextField()
    processed_at = models.DateTimeField(auto_now_add=True)
    chunk_index = models.IntegerField()
    page_number = models.IntegerField()
    chunk_start = models.IntegerField()
    chunk_end = models.IntegerField()
    metadata = models.JSONField(default=dict)
    embeddings_together_m2_bert_80M_2k_retrieval = VectorField(
        dimensions=768,
        help_text="Embeddings generated by Together's m2-bert-80M-2k-retrieval model.",
        null=True,
        blank=True,
    )

    class Meta:
        verbose_name_plural = "File Text Extractions"
        indexes = [
            HnswIndex(
                name='m2_bert_80M_2k_retrieval_index',
                fields=['embeddings_together_m2_bert_80M_2k_retrieval'],
                m=16,
                ef_construction=64,
                opclasses=['vector_cosine_ops']
            )
        ]

    def __str__(self):
        external_id = str(self.id_external)
        return external_id

class Conversation(models.Model):
    id_external = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    associated_file = models.ForeignKey(UploadedFile, on_delete=models.SET_NULL, null=True, blank=True)

    class Meta:
        verbose_name_plural = "Conversations"

    def __str__(self):
        return f"{self.id_external}"

class Message(models.Model):
    ROLE_CHOICES = [
        ('user', 'User'),
        ('assistant', 'Assistant'),
        ('system', 'System'),
    ]

    id_external = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE, related_name='messages')
    role = models.CharField(max_length=10, choices=ROLE_CHOICES)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    embeddings_together_m2_bert_80M_2k_retrieval = VectorField(
        dimensions=768,
        help_text="Embeddings generated by Together's m2-bert-80M-2k-retrieval model for retrieval.",
        null=True,
        blank=True,
    )

    class Meta:
        ordering = ['created_at']

    def __str__(self):
        return f"{self.id_external}"

from ninja import Schema, Field
from pydantic import ConfigDict
from typing import Optional, List

class UploadedFileSchema(Schema):
    id: uuid.UUID = Field(alias='id_external')
    filename: str = Field(alias='file_name')
    file: bytes
    uploaded_at: str

    class Meta:
        model = UploadedFile

class TextExtractionSchema(Schema):
    id: uuid.UUID = Field(alias='id_external')
    file: UploadedFileSchema = Field(alias='source_file')
    extracted_text: str
    processed_at: str

class TextChunkSchema(Schema):
    page_number: int
    chunk_number: int
    chunk: str
    chunk_start: int
    chunk_end: int
    metadata: dict
    chunk_index: int

class ChunkedTextExtractionSchema(Schema):
    extracted_text: list[TextChunkSchema]

class TextInputSchema(Schema):
    text: str

class EmbeddingsSchema(Schema):
    chunk_index: int
    chunk_start: int
    chunk_end: int
    metadata: dict
    embeddings: list[float]

class EmbeddingsListSchema(Schema):
    embeddings: list[EmbeddingsSchema]

class TextEmbeddingsSchema(Schema):
    text: str
    embeddings: list[float]

class ChatInputSchema(Schema):
    query: str
    file: Optional[UploadedFileSchema] = Field(alias='source_file')
    processed_at: datetime

class ChatMessageSchema(Schema):
    role: str
    content: str

class ChatOutputSchema(Schema):
    conversation_id: uuid.UUID
    message: ChatMessageSchema
    response: Optional[str]

class PdfInquestOutputSchema(Schema):
    conversation_id: uuid.UUID
    file_id: uuid.UUID
    text_extractions: list[uuid.UUID]
    response: str

class PdfInquestContinueOutputSchema(Schema):
    conversation_id: uuid.UUID
    response: str

class ChatMessagesSchema(Schema):
    messages: list[ChatMessageSchema]

class ConversationSchema(Schema):
    id: uuid.UUID
    #id: uuid.UUID = Field(alias='id_external')
    created_at: str
    updated_at: str
    associated_file: Optional[str]

class ConversationListSchema(Schema):
    conversations: list[ConversationSchema]

class Source(models.Model):
    id_external = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    name = models.CharField(max_length=255) # Name of the Source instance
    uploaded_files = models.ManyToManyField(UploadedFile, related_name='source_files') # Files associated with the Source
    description = models.TextField(blank=True) # Description of the Source
    source_name = models.CharField(max_length=255) # Name of the source location (e.g. "OneDrive Specifications Folder")
    source_type = models.CharField(max_length=255) # Type of source (e.g. "OneDrive", "URL", "File", "Database", etc.)
    source_format = models.CharField(max_length=255) # Format of the source files (e.g. "PDF", "CSV", "JSON", "MIXED", etc.)
    source_path = models.CharField(max_length=255) # Path to the source (e.g. URL, file path, database name, etc.)
    created_at = models.DateTimeField(auto_now_add=True) # When the Source was created
    updated_at = models.DateTimeField(auto_now=True) # When the Source was last updated
    metadata = models.JSONField(default=dict) # Metadata about the Source
    tags = models.JSONField(default=list) # Tags for the Source

    def __str__(self):
        return self.id_external